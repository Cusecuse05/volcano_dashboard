"""
Name: Marcus White
CS230: Section 4
Data: Volcanoes.csv
URL: N/A

Description:
    This program creates a website which presents and compares information on volcanoes.
    More specifically, it compares based on location and type while also giving having a "random" generator to give you specific information about a random volcano.
"""
import streamlit as st
import pandas as pd
import pydeck as pdk
import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
import random
from streamlit_folium import folium_static
import folium
from folium.plugins import HeatMap

st.set_page_config( #[ST4]
    page_title="Volcano Explorer Dashboard",
    page_icon="üåã",
    layout="wide"
)

@st.cache_data
def load_data(): #[PY2]
    df = pd.read_csv("volcanoes.csv", encoding='latin1', skiprows=1) #skip first line (headings on 2nd)
    rows = len(df)
    return df, rows

df, rows = load_data()

st.title("Volcano Explorer Dashboard")

st.write(f"Loaded {rows} volcano records.")

# Tab Layout (generated by ChatGPT -- see prompt 1)
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "üè† Home ‚Äì Timeline Map",
    "üåç Compare by Location",
    "üåã Compare by Type",
    "üîç Volcano Lookup",
    "üé≤ Random Volcano"
])

with tab1:
    st.header("Timeline Map of Eruptions")
    st.info("This section will display an interactive map showing volcanic eruptions over time.")

    #ChatGPT -- see prompt 2

    #adjust for columns with extra spaces
    df_map = df.copy()
    df_map.columns = df_map.columns.str.strip()

    #extracts year from formated data (ChatGPT -- see prompt 3)
    def extract_year(date_str):
        if isinstance(date_str, str):
            try:
                if "BCE" in date_str:
                    return -int(date_str.split()[0])
                elif "CE" in date_str:
                    return int(date_str.split()[0])
                elif date_str.strip().isdigit():
                    return int(date_str.strip())
            except:
                return None
        return None

    # Ensure the column exists
    if "Last Known Eruption" not in df_map.columns:
        st.error("'Last Known Eruption' column not found.")
        st.stop()

    df_map["Year"] = df_map["Last Known Eruption"].apply(extract_year)
    df_map = df_map.dropna(subset=["Latitude", "Longitude", "Year"]) #[DA1]
    df_map["Year"] = df_map["Year"].astype(int)

    # --- Get Eruption Years Sorted ---
    eruption_years = sorted(df_map["Year"].unique()) #[DA2] sorts years and makes sure that they don't repeat

    # --- Timeline Navigation ---
    if "current_year_index" not in st.session_state:
        st.session_state.current_year_index = 0  # first eruption year

    # --- Control Buttons for Year Navigation ---
    col1, col2, col3 = st.columns([1, 1, 1])
    with col1:
        if st.button("‚¨ÖÔ∏è Jump Back", use_container_width = True):
            if st.session_state.current_year_index > 0:
                st.session_state.current_year_index -= 1  # Go to previous eruption

    with col2:
        current_year = eruption_years[st.session_state.current_year_index]
        st.markdown(f"üïíShowing eruptions in **{current_year}**")

    with col3:
        if st.button("‚û°Ô∏è Jump Forward", use_container_width = True):
            if st.session_state.current_year_index < len(eruption_years) - 1:
                st.session_state.current_year_index += 1  # Go to next eruption

    # --- Filter Data based on the Current Year ---
    current_year = eruption_years[st.session_state.current_year_index]
    filtered = df_map[df_map["Year"] == current_year]

    # --- Define Pydeck Layer ---
    layer = pdk.Layer(
        "ScatterplotLayer",
        data=filtered,
        get_position='[Longitude, Latitude]',
        get_color='[200, 30, 0, 160]',
        get_radius=200000,
        pickable=True,
    )

    # --- Define Pydeck View ---
    view_state = pdk.ViewState(
        latitude=filtered["Latitude"].mean() if not filtered.empty else 0,
        longitude=filtered["Longitude"].mean() if not filtered.empty else 0,
        zoom=2,
        pitch=0,
    )

    # --- Render Map ---
    st.pydeck_chart(pdk.Deck(
        map_style="mapbox://styles/mapbox/light-v9",
        initial_view_state=view_state,
        layers=[layer],
        tooltip={
            "html": "<b>{Volcano Name}</b><br>Country: {Country}<br>Year: {Year}<br>Elevation: {Elevation (m)} m",
            "style": {"backgroundColor": "steelblue", "color": "white"}
        }
    ))

    # Prepare Data (make sure only rows with valid coordinates are included)
    volcano_map_data = df[['Latitude', 'Longitude']].dropna() #[DA1]

    #SEE AI PROMPT #7 [FOLIUM1]

    # Prepare data
    heat_data = volcano_map_data[["Latitude", "Longitude"]].dropna().values.tolist()

    # Create map
    m = folium.Map(location=[0, 0], zoom_start=2)
    HeatMap(heat_data).add_to(m)

    st.subheader("üåã Volcano Heatmap")
    folium_static(m)

with tab2:
    #See AI prompt #4

    st.header("üåç Compare Volcanoes by Location")
    st.info("Filter volcanoes by country, region, or province and visualize different metrics.")

    # --- Clean & Prepare Data --- [DA1]
    df_location = df.copy()
    df_location.columns = df_location.columns.str.strip()

    # --- Filters ---
    countries = df_location["Country"].dropna().unique() #[DA4]

    selected_country = st.selectbox("üåé Select Country", options=np.insert(countries, 0, "All Countries")) #[ST1]

    if selected_country != "All Countries":
        regions = df_location[df_location["Country"] == selected_country]["Volcanic Region"].dropna().unique()
    else:
        regions = df_location["Volcanic Region"].dropna().unique()

    selected_region = st.selectbox("üìç Select Region", options=np.insert(regions, 0, "All Regions")) #[ST2]

    if selected_region != "All Regions":
        provinces = df_location[df_location["Volcanic Region"] == selected_region]["Volcanic Province"].dropna().unique()
    else:
        if selected_country != "All Countries":
            provinces = df_location[df_location["Country"] == selected_country]["Volcanic Province"].dropna().unique()
        else:
            provinces = df_location["Volcanic Province"].dropna().unique()

    selected_province = st.selectbox("üèîÔ∏è Select Province", options=np.insert(provinces, 0, "All Provinces")) #[ST3]

    # --- Apply Filters --- [DA5]
    filtered = df_location.copy()
    if selected_country != "All Countries":
        filtered = filtered[filtered["Country"] == selected_country]
    if selected_region != "All Regions":
        filtered = filtered[filtered["Volcanic Region"] == selected_region]
    if selected_province != "All Provinces":
        filtered = filtered[filtered["Volcanic Province"] == selected_province]

    st.subheader(f"üîé Showing {len(filtered)} volcanoes after filtering")

    # --- Charts ---
    st.divider()

    # 1. Number of Volcanoes per Country/Region
    st.subheader("üåã Number of Volcanoes")
    if selected_country == "All Countries":
        volcano_counts = filtered["Country"].value_counts().reset_index() #[DA4]
        volcano_counts.columns = ["Location", "Volcano Count"]
    elif selected_region == "All Regions":
        volcano_counts = filtered["Volcanic Region"].value_counts().reset_index() #[DA4]
        volcano_counts.columns = ["Location", "Volcano Count"]
    else:
        volcano_counts = filtered["Volcanic Province"].value_counts().reset_index() #[DA4]
        volcano_counts.columns = ["Location", "Volcano Count"]

    # Count volcanoes per country [CHART1]
    volcano_counts = filtered["Country"].value_counts().head(10)

    fig, ax = plt.subplots()
    volcano_counts.plot(kind="bar", ax=ax)
    ax.set_title("Top 10 Countries by Number of Volcanoes")
    ax.set_xlabel("Country")
    ax.set_ylabel("Number of Volcanoes")
    st.pyplot(fig)

    st.divider()

    # 2. Average Elevation by Region
    st.subheader("‚õ∞Ô∏è Average Elevation by Location")
    if selected_country == "All Countries":
        elevation_avg = filtered.groupby("Country")["Elevation (m)"].mean().reset_index()
    elif selected_region == "All Regions":
        elevation_avg = filtered.groupby("Volcanic Region")["Elevation (m)"].mean().reset_index()
    else:
        elevation_avg = filtered.groupby("Volcanic Province")["Elevation (m)"].mean().reset_index()

    elevation_avg.columns = ["Location", "Average Elevation (m)"]

    fig2 = px.bar(
        elevation_avg,
        x="Location",
        y="Average Elevation (m)",
        title="Average Elevation",
        labels={"Location": "Location", "Average Elevation (m)": "Average Elevation (m)"},
        color="Average Elevation (m)",
        color_continuous_scale="viridis"
    )
    fig2.update_layout(xaxis_tickangle=-45)
    st.plotly_chart(fig2, use_container_width=True)

    st.divider()

    # 3. Most Common Volcano Types
    st.subheader("üß± Most Common Volcano Types")
    volcano_types = filtered["Primary Volcano Type"].value_counts().reset_index()
    volcano_types.columns = ["Volcano Type", "Count"]

    fig3 = px.bar(
        volcano_types,
        x="Volcano Type",
        y="Count",
        title="Most Common Volcano Types",
        labels={"Volcano Type": "Volcano Type", "Count": "Count"},
        color="Count",
        color_continuous_scale="plasma"
    )
    fig3.update_layout(xaxis_tickangle=-45)
    st.plotly_chart(fig3, use_container_width=True)

    # [CHART2]
    fig, ax = plt.subplots()
    ax.hist(filtered["Elevation (m)"].dropna(), bins=20, color="orange", edgecolor="black")
    ax.set_title("Distribution of Volcano Elevations")
    ax.set_xlabel("Elevation (m)")
    ax.set_ylabel("Frequency")
    st.pyplot(fig)

with tab3:
    #SEE AI PROMPT 5
    st.header("üåã Compare Volcanoes by Type")
    st.info("Select volcano types to compare their elevation, activity, eruption history, and tectonic settings.")

    # --- Clean & Prepare Data ---
    df_type = df.copy()
    df_type.columns = df_type.columns.str.strip()

    # --- Multiselect for Volcano Types ---
    available_types = df_type["Primary Volcano Type"].dropna().unique()
    selected_types = st.multiselect("üß± Select Volcano Types", options=available_types)

    # --- Filter based on selection ---
    if selected_types:
        filtered_type = df_type[df_type["Primary Volcano Type"].isin(selected_types)]
    else:
        filtered_type = df_type.copy()

    st.subheader(f"üîé Showing {len(filtered_type)} volcanoes")

    st.divider()

    # 1. Volcano Count per Type (Pie or Bar Chart)
    st.subheader("üåã Volcano Count per Type")
    type_counts = filtered_type["Primary Volcano Type"].value_counts().reset_index()
    type_counts.columns = ["Volcano Type", "Count"]

    chart_type = st.radio("Choose chart style:", ["Pie Chart", "Bar Chart"], horizontal=True)

    if chart_type == "Pie Chart":
        fig_count = px.pie(
            type_counts,
            names="Volcano Type",
            values="Count",
            title="Volcano Distribution by Type",
            hole=0.3
        )
    else:
        fig_count = px.bar(
            type_counts,
            x="Volcano Type",
            y="Count",
            title="Volcano Distribution by Type",
            color="Count",
            color_continuous_scale="blues"
        )
        fig_count.update_layout(xaxis_tickangle=-45)

    st.plotly_chart(fig_count, use_container_width=True)

    st.divider()

    # 2. Elevation Distributions (Box Plot)
    st.subheader("‚õ∞Ô∏è Elevation Distribution by Type")
    fig_elevation = px.box(
        filtered_type,
        x="Primary Volcano Type",
        y="Elevation (m)",
        title="Elevation Distribution by Volcano Type",
        color="Primary Volcano Type"
    )
    fig_elevation.update_layout(xaxis_tickangle=-45)
    st.plotly_chart(fig_elevation, use_container_width=True)

    st.divider()

    # 4. Activity Evidence (Bar Chart)
    st.subheader("üî• Activity Level Distribution")

    activity_counts = filtered_type["Activity Evidence"].value_counts().reset_index()
    activity_counts.columns = ["Activity Level", "Count"]

    fig_activity = px.bar(
        activity_counts,
        x="Activity Level",
        y="Count",
        title="Activity Levels of Selected Volcano Types",
        color="Count",
        color_continuous_scale="oranges"
    )
    fig_activity.update_layout(xaxis_tickangle=-45)
    st.plotly_chart(fig_activity, use_container_width=True)

#SEE AI PROMPT 8 -- added last
with tab4:
    st.header("Manual Volcano Lookup")

    volcano_name_input = st.text_input("Enter the name of a volcano:")

    # Create a dictionary for quick lookup
    volcano_dict = {name.lower(): row for name, row in zip(df['Volcano Name'], df.to_dict('records'))}

    if volcano_name_input:
        try: #[PY3]
            # Use list comprehension to match user input (case insensitive) [PY4]
            matched = [volcano_dict[name] for name in volcano_dict.keys() if volcano_name_input.lower() == name]

            if matched:
                st.subheader("Volcano Information:")
                for key, value in matched[0].items():  # Dictionary access using .items() [PY5]
                    st.write(f"**{key}:** {value}")

                # Volcano location map
                st.markdown("### üó∫Ô∏è Volcano Location")
                location_df = pd.DataFrame({
                    "lat": [matched[0]["Latitude"]],
                    "lon": [matched[0]["Longitude"]]
                })
                st.map(location_df)
            else:
                st.warning("No volcano found with that name. Please check your spelling.")
        except Exception as e:
            st.error(f"An error occurred: {e}")

with tab5:
    #SEE AI PROMPT 6
    st.header("üé≤ Random Volcano Spotlight")
    st.info("Click the button to discover a random volcano and explore its details!")

    # Initialize a random volcano selection
    if "random_volcano" not in st.session_state:
        st.session_state.random_volcano = df.sample(1).iloc[0]

    # Shuffle Button
    if st.button("üîÄ Shuffle Volcano"):
        st.session_state.random_volcano = df.sample(1).iloc[0]

    volcano = st.session_state.random_volcano

    # --- Volcano Card ---
    st.subheader(f"üåã {volcano['Volcano Name']}")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown(f"**üìç Location:** {volcano['Country']}, {volcano['Volcanic Region']}, {volcano['Volcanic Province']}")
        st.markdown(f"**üìè Elevation:** {volcano['Elevation (m)']} meters")
        st.markdown(f"**ü™® Type:** {volcano['Primary Volcano Type']}")
        st.markdown(f"**üèûÔ∏è Landform:** {volcano['Volcano Landform']}")
        st.markdown(f"**üß± Dominant Rock Type:** {volcano['Dominant Rock Type']}")

    with col2:
        st.markdown(f"**üåã Last Known Eruption:** {volcano['Last Known Eruption']}")
        st.markdown(f"**üî• Activity Evidence:** {volcano['Activity Evidence']}")
        st.markdown(f"**üåé Latitude:** {volcano['Latitude']}")
        st.markdown(f"**üåç Longitude:** {volcano['Longitude']}")

    # --- Mini Map ---
    st.markdown("### üó∫Ô∏è Volcano Location")
    st.map(pd.DataFrame({ #[MAP]
        "lat": [volcano["Latitude"]],
        "lon": [volcano["Longitude"]]
    }))

